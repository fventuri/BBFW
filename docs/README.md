# Useful references

## Overview of the x6100's hardware and software
The Xiegu x6100 is a portable 10W (5W on battery power) 'all-mode' SDR transceiver designed for amatuer use.  Thanks to analysis of high-resolution photos ([1](https://gist.github.com/djbr1/3c1410523d05bb0e2a2595a3d169718c), [2](https://github.com/TemporarilyOffline/X6100-TOADs)) of the radio internals and previous work on other Xiegu radios, we know that the radio consists of a "Display Unit" ("front end") and a "Base Unit" ("back end" / "baseband"), which are analagous to a Raspberry Pi tablet duct taped on top of an FT-817's control panel.
 - The x6100's DispUnit is the Raspberry Pi tablet in our analogy: The DispUnit controls software for the LCD GUI/display and for audio interpretation (aka modems).  The Display Unit is run by an onboard ARM Cortex-A7 single-board-computer ("SBC"), a [MYZR Allwinner R16 CB166](https://www.myzr-tech.com/system-on-module/allwinner-som/r16-cpu-module.html).  This ARM SBC has its own operating system, which consists of Linux firmware (with proprietary display driver and many opensource drivers) and a Linux U-boot bootloader.  The DispUnit SBC's firmware has been thoroughly [reverse engineered](https://github.com/AetherRadio/awesome-x6100) by [Strijar (R1CBU)](https://r1cbu.ru/), LordKalma (CT7ALW), and others.  The reverse engineered frontend can run audio modems to decode/encode CW, RTTY, FT8, and others, self-contained within the x6100.
 - The x6100's BaseUnit is the FT-817's control panel in our analogy: The BaseUnit can be thought of as the 'actual radio' - or the simple control panel of the radio - which controls the sending/recieving of radio & audio signals from the radio's hardware devices.  The Base Unit is run by an onboard [STMicroelectronics STM32F427ZGT6](https://www.st.com/en/microcontrollers-microprocessors/stm32f427zg.html), which is a 32-bit ARM [Cortex-M4](https://developer.arm.com/Processors/Cortex-M4) system-on-chip ("SoC").  The STM32F4 uses [little-endian](https://www.st.com/resource/en/programming_manual/pm0214-stm32-cortexm4-mcus-and-mpus-programming-manual-stmicroelectronics.pdf#page=34) formatting, has a well-documented [memory map](https://www.st.com/resource/en/datasheet/stm32f427zg.pdf#page=86), [GPIO](https://www.st.com/resource/en/reference_manual/rm0090-stm32f405415-stm32f407417-stm32f427437-and-stm32f429439-advanced-armbased-32bit-mcus-stmicroelectronics.pdf#page=281), [vector table (p36)](https://developer.arm.com/documentation/dui0553/b/?lang=en), and [opensource libraries](https://github.com/STMicroelectronics/STM32CubeF4) for many functions and [peripherals](https://github.com/mfauzi/STM32F4/tree/master/STM32F4%20Standard%20Peripheral%20Library).  Xiegu's STM32 firmware is sometimes referred to as "G-Core" firmware since the Xiegu G90 & G106 radios are also built around this frontend SBC / backend STM32 SoC model and are also controlled by similar STM32 firmware.  The G90 has been extensively researched & reversed and the tools created for it can be used to help reverse engineer the x6100.  The TYT MD-380 is a handheld UHF radio which is also controlled by an STM32 which has also been [reverse engineered](https://github.com/angea/pocorgtfo/blob/master/contents/issue10.pdf#page=76) by [Travis Goodspeed (KK4VCZ)](https://github.com/travisgoodspeed/md380tools).  The STM32 base unit (aka 'baseband') firmware, which sits at address 0x08020000 inside flash memory, is different than the STM32 base unit bootloader, which probably sits near 0x08000000 in flash memory.  The STM32 has [readout protection](https://stm32world.com/wiki/STM32_Readout_Protection_(RDP)) (also see [1](https://www.st.com/resource/en/product_training/STM32F7_Security_Memories_Protections.pdf), [2](https://www.st.com/content/ccc/resource/technical/document/application_note/group1/5f/8e/48/4c/1f/e1/41/0f/DM00684243/files/DM00684243.pdf/jcr:content/translations/en.DM00684243.pdf), [3](https://www.st.com/content/ccc/resource/technical/document/application_note/group1/9f/0b/e4/b6/75/15/4f/e2/DM00493651/files/DM00493651.pdf/jcr:content/translations/en.DM00493651.pdf)) which will erase both the bootloader & firmware if tripped incorrectly.

## Obtaining a x6100 Base Unit STM32 firmware file
The x6100's STM32 base unit _bootloader file_ can only be extracted from a radio unit.  However, the STM32 base unit firmware file can be easily extracted from official firmware updates - downloadable directly from [Radioddity](https://www.radioddity.com/pages/xiegu-download), which sells the x6100.  Inside compressed firmware update archive, you can find the x6100 STM32 base unit firmware file in either `Xiegu_X6100_Firmware_Upgrade_20221124.zip/Firmware/sdcard_20221124.img/1.img/usr/firmware/X6100_BBFW_V1.1.6_221112001.xgf` or `Xiegu_X6100_Firmware_Upgrade_20221124.zip/Firmware/sdcard_20221124.img/2.fat/rootfs.tar/./usr/firmware/X6100_BBFW_V1.1.6_221112001.xgf`.  The firmware file is encrypted with an AES-256 key (you will either need to find the key online or extract the key from your radio following the _"Bootloader extraction procedure from Xiegu G90 processors"_ article below).  Once you have the key, you will be able to decrypt 'X6100_BBFW_V1.1.6_221112001.xgf' (for example) using [G90 Tools](https://github.com/OpenHamradioFirmware/G90Tools).  Firmware CRC's are [available here](x6100_firmware_hashes.csv) for reference.

## Primer on reverse engineering STM32 firmware
 - Online classes for beginners to Ghidra, IDA, ARM Assembly Language, STM32Cube, and even Cutter/Radare2 are available online (Udemy has sales every month).
 - [Nifty Tricks for ARM Firmware Reverse Engineering](https://www.youtube.com/watch?v=GX8-K4TssjY) (Travis Goodspeed, BalCCon2k16 10/2016)
_STM32 firmware/bootloader dumping, symgrate (an online database to match ARM assembly signatures to known opensource functions), and ARM firmware emulation on x86 with qemu. Travis Goodspeed reverse engineered the TYT MD-380 radio's firmware. He is a member of [PoC||GTFO](https://github.com/angea/pocorgtfo) & Strawhat Security._
 - [Some Thoughts on Literate Disassembly and Symbol Porting](https://www.youtube.com/watch?v=1zwthRJ7PP8) (Travis Goodspeed, Hacktivity 10/2017)
_Identifying project scope, ideas for automating/helping function discovery (the c compiler might have clumped functions in the same library together in memory, referencing opensource libraries), labeling functions according to guesses (`function_g`) or facts (`function_f`), using emulation to test RE hypothesis without needing hardware, keeping information in text files (track guesses/facts, who added, who last modified) and scripts instead of decompiler databases for portability/collaboration & version control, collaborators can work with their own favorite decompilers. "Have scripts to parse all of your data and keep everything in flat text files so that you can rebuild it in a new reverse engineering tomorrow if you have to."_
 - [Bootloader extraction procedure from Xiegu G90 processors](https://radiochief.ru/radio/protsedura-izvlecheniya-bootloader-iz-xiegu-g90/) (Denis Dubov, Radiochief.ru magazine 06/2022)
_Dumping firmware and bootloaders._			
 - [Firmware Reverse Engineering with Ghidra - Day 1](https://www.youtube.com/watch?v=244XX6x3-C0) (Thomas Roth, Advanced Security Training 05/2020)
_How to initially import your firmware file into Ghidra._
 - [Bare-metal ARM firmware reverse engineering with Ghidra and SVD-Loader](https://youtu.be/q4CxE5P6RUE?t=125) (Thomas Roth, stacksmashing 02/2020)
_How to set up a memory map for your firmware file in Ghidra.  Also a crackme challenge._
 - [Firmware Reverse Engineering with Ghidra - Day 2](https://www.youtube.com/watch?v=CRT118BgVZ0) (Thomas Roth, Advanced Security Training 05/2020)
_More info about setting up memory maps (with the SVD Loader Ghidra script)._
 - [Analyzing bare metal firmware binaries in Ghidra](https://blog.attify.com/analyzing-bare-metal-firmware-binaries-in-ghidra/) (Attify 10/2021)
_Another perspective on using SVD Loader to set up memory maps for STM32 firmware_.
 - [Decompiling ARM raw binary with Ghidra](https://www.youtube.com/watch?v=YjLFoiBdWpE)
_Decompiling/reversing ARM machine code to C code_
 - [ARM Cortex-M Startup Code](https://www.iotality.com/arm-cortex-m4-startup-code/)

### One reversing workflow
 1. Identify processor via hardware components on PCB's, googling model numbers, and obtaining manufacturer documentation. Also obtain decrypted firmware for main processor.
 2. Load decrypted firmware file into Ghidra.  Tell Ghidra how to interpret the file via the processor's manufacturer documentation and any opensource libraries (ARM Cortex M4 instructions? little endian address format? Thumb instructions? Memory map information / SVD file?).  Once Ghidra knows where pointers are going, output might make more sense.  See above.
 3. Run the code through an instruction signature/fingerprint database like symgrate to see if any functions/symbols are already known and can be labelled.  Apply struct info to any identified functions (GDT file).
 4. Read everything you can find on reversing this kind of firmware to look for clues: Virtual address table is in the documentation? Great, fill that into your database.  The second pointer at the beginning of this kind of firmware usually leads to main()? Great! Look for main().
 5. Search for strings and see which functions reference those strings.  Start giving those functions guessed names based on the strings they use (for example: Are there a lot of battery strings being referenced by the function?  Name the function 'batteryStuff_g_').  Try to be as specific as you can but don't get hung up on details yet.
 6. If a bunch of strings (or string pointers) are in the same area, look at other things there to see if the disassembler might have misidentified things.  See if you can changed any unidentified bytes into part of the rest of the string so that the pointer reports the string instead of just a memory address.

_for example_
```asm
        xxxxxxxx 0d              ??         0Dh
        xxxxxxxx 08              ??         08h
        xxxxxxxx 65 72 72        ds         "error: no data found.\r"
                 6f 72 3a 
                 67 3a 20 ...
```
_might actually be supposed to point to_
```asm
        xxxxxxxx 0d 08 65        ds         "\r\berror: no data found.\r"
                 72 72 6f 
                 72 3a 67 ...
```

 7. Start looking for any unknown simple or commonly-used functions and name them with guesses about what they do.  For identified functions, see what clusters of functions they call and see if you can give those functions name-guesses based on what the parent function does and what variables are being passed into those.  See if the compiler put a bunch of similar functions (from the math or graphics library for example) all clumped together near the same memory addresses so that you can guess at what other unknown functions in those memory ranges might do.  Hopefully a foggy picture of what is basically going on in the firmware will start to emerge.  Write down your guesses/findings in a text file (address, structure_name_g_, your name, notes) so that others can collaborate.
 8. Further into reversing, start testing guesses by inputting values into an emulator of the firmware.
